using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Order;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;

namespace leveledlistresolver
{
    class Program
    {
        private static Lazy<ProgramSettings>? _settings;

        public static ILinkCache<ISkyrimMod, ISkyrimModGetter> LinkCache { get; set; } = new LoadOrder<ISkyrimModGetter>().ToImmutableLinkCache();
        public static ProgramSettings Settings { get => _settings?.Value ?? throw new ArgumentNullException(); }

        private static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance.SetTypicalOpen(GameRelease.SkyrimSE, new("Leveled Lists", ModType.Plugin))
                .SetAutogeneratedSettings("Settings", "Settings.json", out _settings)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(Apply)
                .Run(args);
        }

        public static void Apply(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("Report issues at https://github.com/OddDrifter/leveledlistresolver/issues");

            using var loadOrder = state.LoadOrder;

            loadOrder.Items.Select(static i => i.Mod).NotNull()
                .Where(static i => string.Equals(i.ModHeader.Author, "Bashed Patch", StringComparison.OrdinalIgnoreCase))
                .Where(static i => i.LeveledItems.Any() || i.LeveledNpcs.Any() || i.LeveledSpells.Any())
                .ForEach(i => Settings.BlacklistedPlugins.Add(i.ModKey));

            bool removed = Settings.BlacklistedPlugins.Any();
            while (removed)
            {
                removed = false;
                foreach (var listing in loadOrder.Items)
                {
                    if (listing is not { Enabled: true, ExistsOnDisk: true, Mod: { } })
                        continue;

                    if (listing.Mod.MasterReferences.Any(i => Settings.BlacklistedPlugins.Contains(i.Master)))
                    {
                        if (Settings.BlacklistedPlugins.Add(listing.ModKey))
                            removed = true;
                    }
                }
            }

            foreach (var (plugin, last) in Settings.BlacklistedPlugins.IterateMarkLast())
            {
                if (loadOrder.RemoveKey(plugin))
                    Console.WriteLine($"{plugin} was blacklisted{(last ? Environment.NewLine : string.Empty)}");
            }
            LinkCache = loadOrder.ToMutableLinkCache(state.PatchMod);

            var enabledAndExisting = loadOrder.PriorityOrder.OnlyEnabledAndExisting().ToImmutableArray();
            var comparer = ModKey.LoadOrderComparer(loadOrder.Keys.ToImmutableArray());

            foreach (var leveledItem in enabledAndExisting.LeveledItem().WinningOverrides().OrderBy(static i => i.FormKey.ModKey, comparer).ThenBy(static i => i.FormKey.ID))
            {
                if (RecordPatcher.TryPatch(state, leveledItem, out LeveledItem? copy))
                    state.PatchMod.LeveledItems.Set(copy);
            }

            foreach (var leveledNpc in enabledAndExisting.LeveledNpc().WinningOverrides().OrderBy(static i => i.FormKey.ModKey, comparer).ThenBy(static i => i.FormKey.ID))
            {
                if (RecordPatcher.TryPatch(state, leveledNpc, out LeveledNpc? copy))
                    state.PatchMod.LeveledNpcs.Set(copy);
            }

            foreach (var leveledSpell in enabledAndExisting.LeveledSpell().WinningOverrides().OrderBy(static i => i.FormKey.ModKey, comparer).ThenBy(static i => i.FormKey.ID))
            {
                if (RecordPatcher.TryPatch(state, leveledSpell, out LeveledSpell? copy))
                    state.PatchMod.LeveledSpells.Set(copy);
            }
        }      
    }
}